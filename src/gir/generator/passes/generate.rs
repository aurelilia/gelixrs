use std::rc::Rc;

use crate::{
    ast::Constructor,
    gir::{
        generator::GIRGenerator,
        nodes::{
            declaration::{Declaration, Field, Function, ADT},
            expression::Expr,
            types::{IFaceImpls, Type},
        },
        MutRc, IFACE_IMPLS,
    },
    lexer::token::Token,
};
use indexmap::map::IndexMap;
use smol_str::SmolStr;
use std::iter;

impl GIRGenerator {
    pub fn generate(&mut self, decl: Declaration) {
        match decl {
            Declaration::Function(func) => self.generate_function(&func),

            Declaration::Adt(adt_rc) => {
                let adt = adt_rc.borrow();
                self.generate_constructors(&adt);
                for (index, method) in adt.methods.values().enumerate() {
                    self.generate_function_(method, index);
                }
            }
        }
    }

    pub fn generate_impls(&mut self) {
        IFACE_IMPLS.with(|i| {
            for impls in i.borrow().values() {
                self.generate_impl(impls)
            }
        })
    }

    pub fn generate_impl(&mut self, impls: &MutRc<IFaceImpls>) {
        let impls = impls.borrow();
        for im in impls.interfaces.values() {
            self.switch_module(Rc::clone(&im.module));
            for method in im.methods.values() {
                self.generate_function(method);
            }
        }
    }

    pub fn generate_function(&mut self, function: &MutRc<Function>) {
        self.generate_function_(function, 0);
    }

    fn generate_function_(&mut self, function: &MutRc<Function>, index: usize) {
        if !function.borrow().exprs.is_empty() {
            // Shared function references can cause this fn to be called
            // multiple times (enum cases for example)
            return;
        }

        self.prepare_function(&function);
        let ast = Rc::clone(&function.borrow().ast);

        let body = match &ast.borrow().body.as_ref() {
            Some(body) => self.expression(body),
            None if ast.borrow().sig.is_extern() => return,
            None => self.iface_method_body(function, index),
        };

        let ret_type = function.borrow().ret_type.clone();
        let (body, success) = self.resolver.try_cast(body, &ret_type);
        if !success && ret_type != Type::None {
            self.err(
                &ast.borrow().sig.name.clone(),
                format!(
                    "Function return type ({}) does not match body type ({}).",
                    ret_type,
                    body.get_type()
                ),
            );
        }

        if ret_type == Type::None {
            self.insert_at_ptr(body)
        } else {
            self.insert_at_ptr(Expr::ret(body));
        }
        self.end_scope();
    }

    /// This method generates the method body for an iface function.
    /// The method simply delegates to the implementor.
    fn iface_method_body(&mut self, function: &MutRc<Function>, index: usize) -> Expr {
        let args = function
            .borrow()
            .parameters
            .iter()
            .skip(1)
            .map(|p| Expr::lvar(p))
            .collect();
        Expr::iface_call(
            Expr::lvar(&function.borrow().parameters[0]),
            index + 1,
            args,
        )
    }

    fn generate_constructors(&mut self, adt: &ADT) {
        let ast = adt.ast.borrow();
        if let Some(constructors) = ast.constructors() {
            for (ast, constructor) in constructors
                .iter()
                .map(Some)
                .chain(iter::repeat(None))
                .zip(adt.constructors.iter())
            {
                self.prepare_function(constructor);
                self.insert_at_ptr(Expr::none_const_());

                // AST must be optional as the autogenerated default constructor does not have one
                if let Some(ast) = ast {
                    self.set_uninitialized_members(ast, &adt.fields);
                    if let Some(body) = &ast.body {
                        let body = self.expression(body);
                        self.insert_at_ptr(body);
                    }
                    self.check_no_uninitialized(&adt.name);
                }

                self.end_scope();
            }

            self.uninitialized_this_fields.clear();
        }
    }

    /// Sets all fields that are uninitialized before the constructor
    /// and must be set by it.
    fn set_uninitialized_members(
        &mut self,
        constructor: &Constructor,
        class_mems: &IndexMap<SmolStr, Rc<Field>>,
    ) {
        self.uninitialized_this_fields.clear();
        for (name, mem) in class_mems.iter() {
            let initialized = constructor
                .parameters
                .iter()
                .filter(|p| p.1.is_none())
                .any(|p| &p.0.lexeme == name);
            if !initialized && mem.initializer.borrow().is_none() {
                self.uninitialized_this_fields.insert(Rc::clone(&mem));
            }
        }
    }

    /// Creates an error if any field is still uninitialized after a constructor.
    fn check_no_uninitialized(&mut self, err_tok: &Token) {
        if !self.uninitialized_this_fields.is_empty() {
            self.err(
                err_tok,
                "Cannot have uninitialized fields after constructor.".to_string(),
            )
        }
    }

    /// Will append an 'entry' block to the fn and set the pointer at
    /// that location, then insert all parameters as variables.
    fn prepare_function(&mut self, function: &MutRc<Function>) {
        self.set_pointer(function);
        self.begin_scope();
        let func = function.borrow();
        for param in &func.parameters {
            self.insert_variable(&param, false);
        }
    }
}
