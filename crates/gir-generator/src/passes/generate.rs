use std::rc::Rc;

use crate::GIRGenerator;
use common::MutRc;
use error::GErr;
use gir_nodes::{
    declaration::Field, types::ToInstance, Declaration, Expr, Function, IFaceImpls, Type, ADT,
};
use indexmap::map::IndexMap;
use smol_str::SmolStr;
use std::iter;

impl GIRGenerator {
    pub(super) fn generate(&mut self, decl: Declaration) {
        match decl {
            Declaration::Function(func) => self.generate_function(&func),

            Declaration::Adt(adt_rc) => {
                self.ty_position = Some(adt_rc.to_type());
                let adt = adt_rc.borrow();
                self.generate_constructors(&adt);
                for (index, method) in adt.methods.values().enumerate() {
                    self.generate_function_(method, Some(index));
                }
                self.ty_position = None;
            }
        }
    }

    pub(super) fn generate_impls(&mut self) {
        // TODO Maybe figure out borrowing here, might not be worth it
        let clone = self.iface_impls.values().cloned().collect::<Vec<_>>();
        for impls in clone {
            self.generate_impl(&impls);
        }
    }

    fn generate_impl(&mut self, impls: &MutRc<IFaceImpls>) {
        let impls = impls.borrow();
        self.ty_position = Some(impls.implementor.clone());
        for im in impls
            .interfaces
            .values()
            .filter(|im| !im.module.borrow().compiled)
        {
            self.switch_module(Rc::clone(&im.module));
            for method in im.methods.values() {
                self.generate_function(method);
            }
        }
        self.ty_position = None;
    }

    pub(crate) fn generate_function(&mut self, function: &MutRc<Function>) {
        self.generate_function_(function, None);
    }

    fn generate_function_(&mut self, function: &MutRc<Function>, method_index: Option<usize>) {
        if !function.borrow().exprs.is_empty() {
            // Shared function references can cause this fn to be called
            // multiple times (enum cases for example)
            return;
        }

        self.prepare_function(&function);
        let ast = function.borrow().ast.clone();

        let body = match (ast.as_ref().map(|a| a.body()).flatten(), method_index) {
            (Some(body), _) => self.expression(&body),
            (None, Some(index)) => self.iface_method_body(function, index),
            _ => return,
        };

        let ret_type = function.borrow().ret_type.clone();
        if ret_type == Type::None {
            self.insert_at_ptr(body)
        } else {
            let (body, success) = self.try_cast(body, &ret_type);
            if !success {
                self.err(
                    ast.unwrap().sig().name().cst,
                    GErr::E310 {
                        expected: ret_type.to_string(),
                        was: body.get_type().to_string(),
                    },
                );
            }
            self.insert_at_ptr(Expr::ret(body));
        }

        self.end_scope();
    }

    /// This method generates the method body for an iface function.
    /// The method simply delegates to the implementor.
    fn iface_method_body(&mut self, function: &MutRc<Function>, index: usize) -> Expr {
        let args = function
            .borrow()
            .parameters
            .iter()
            .skip(1)
            .map(|p| Expr::lvar(p))
            .collect();
        Expr::iface_call(
            Expr::lvar(&function.borrow().parameters[0]),
            index + 1,
            args,
            function.borrow().ret_type.clone(),
        )
    }

    fn generate_constructors(&mut self, adt: &ADT) {
        for (ast, constructor) in adt
            .ast
            .constructors()
            .map(Some)
            .chain(iter::repeat(None))
            .zip(adt.constructors.iter())
        {
            self.prepare_function(constructor);
            self.insert_at_ptr(Expr::none_const());

            // AST must be optional as the autogenerated default constructor does not have one
            if let Some(ast) = ast {
                self.set_uninitialized_members(&ast, &adt.fields);
                if let Some(body) = &ast.body() {
                    let body = self.expression(&body);
                    self.insert_at_ptr(body);
                }
                self.check_no_uninitialized(&ast);
            }

            self.end_scope();
        }

        self.uninitialized_this_fields.clear();
    }

    /// Sets all fields that are uninitialized before the constructor
    /// and must be set by it.
    fn set_uninitialized_members(
        &mut self,
        constructor: &ast::Function,
        class_mems: &IndexMap<SmolStr, Rc<Field>>,
    ) {
        self.uninitialized_this_fields.clear();
        for (name, mem) in class_mems.iter() {
            let initialized = constructor
                .sig()
                .parameters()
                .filter(|p| p.maybe_type().is_none())
                .any(|p| &p.name() == name);
            if !initialized && !mem.initialized {
                self.uninitialized_this_fields.insert(Rc::clone(&mem));
            }
        }
    }

    /// Creates an error if any field is still uninitialized after a constructor.
    fn check_no_uninitialized(&mut self, err_ast: &ast::Function) {
        if !self.uninitialized_this_fields.is_empty() {
            self.err(
                err_ast.sig().cst,
                GErr::E309(
                    self.uninitialized_this_fields
                        .iter()
                        .map(|f| f.name.clone())
                        .collect(),
                ),
            )
        }
    }

    /// Will append an 'entry' block to the fn and set the pointer at
    /// that location, then insert all parameters as variables.
    fn prepare_function(&mut self, function: &MutRc<Function>) {
        self.set_pointer(function);
        self.begin_scope();
        let func = function.borrow();
        for param in &func.parameters {
            self.insert_variable(&param, false, None);
        }
    }
}
