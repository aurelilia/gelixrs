import std/intrinsics/puts
import std/intrinsics/sprintf

func print(a: ToString) {
    puts(a.to_string())
}

// TODO: Finish 'String' to allow using sprintf,
// then depreciate this.
extern func printnum(a: i64)

/*
// A simple, fixed-size array type.
// E is the type of values it can hold.
//
// To access array items, use the index operator: array[index]
// Accessing an item above the index will cause a crash.
//
// To create a new array, use a literal:
// val arr = [0, 1, 2, 3]
// val text = ["Hello", "I'm", "A", "String", "Array!"]
//
// This is not valid since the type of elements cannot be inferred:
// val a = []
//
// Retrieving elements works as you'd expect using indexing syntax:
// print([2, 123, 312][1]) // prints 123
//
// Note on the internal implementation in LLVM IR:
// The array's IR struct contains a hidden field, which is a
// pointer to the beginning of the array (its first element).
// Indexing is then implemented in IR directly by using the GEP instruction.
class Array<E> {
    val len = 0
}

// A UTF-8 string.
class String {
    val chars = [i8]

    func len() -> i64 this.chars.len
}
*/

// An interface for types that can be represented as a string.
// Note that generally, toString should not expose the implementation
// of the type, but instead be information relevant to the user.
//
// For example, a 'Person' class might return its name and age
// in a human-readable format.
interface ToString {
    func to_string() -> String
}

impl ToString for bool {
    func to_string() -> String {
        if (this) "true"
        else "false"
    }
}

impl ToString for String {
    func to_string() -> String this
}

impl ToString for i64 {
    func to_string() -> String {
        // This buffer is 20 bytes long.
        // This length is enough to display the largest
        // 64bit int: âˆ’9223372036854775808
        var buffer = "                    "
        sprintf(buffer, "%d", this)
        buffer
    }
}