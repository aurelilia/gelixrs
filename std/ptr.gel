import std/intrinsics/+
import std/memory/Free

/// Returns the size of a type, in bytes. Equivalent to C's sizeof()
public func size_of<T>() -> i64 {
    gelixrs_get_type_size::<T>()
}

/// A pointer to a type.
/// For non-ADT types, this is actually a pointer.
/// For ADT types, which are already a pointer, it simply exposes unsafe methods.
/// Should you misuse a pointer and try to dereference
/// invalid memory, gelix will simply crash at runtime.
///
/// This pointer is partially memory-managed.
/// It will automatically deallocate itself when picked up by the GC,
/// but it will NOT modify the reference counters on the values written to it.
/// Because of this, you are responsible for incrementing/decrementing them
/// as appropriate, using the functions in the class.
///
/// To obtain a heap-allocated pointer, use `allocate`.
public class Ptr<E> {

    /// The location of the pointer in memory.
    /// Converted to an actual pointer when required.
    private var pointer: i64

    /// If this pointer points to the heap.
    /// This is used to decide if the pointer
    /// should be passed to free() on GC.
    private val heap: bool

    /// Create a new pointer given the location in memory.
    private construct(pointer, heap)

    /// Returns the element at the given `index`.
    /// Similar to C array indexing - 0 is the
    /// pointer itself, 1 is (ptr + (1 * sizeof(T))) and so on.
    public func element_at_index(index: i64) -> E {
        val index = this.pointer + (index * size_of::<E>())
        gelixrs_deref_ptr::<E>(index)
    }

    /// Returns a new `Ptr` that starts at the given index.
    /// This new pointer will always have `heap == false`
    /// to prevent it from freeing memory it does not own.
    ///
    /// Because of this, a pointer created by this method is meant to
    /// be temporary. It must NOT outlive it's parent pointer, or
    /// it will point to deallocated data.
    public func ptr_at_index(index: i64) -> Ptr<E> {
        val index = this.pointer + (index * size_of::<E>())
        Ptr::<E>(index, false)
    }

    public func set(index: i64, data: E) {
        val index = this.pointer + (index * size_of::<E>())
        gelixrs_set_ptr::<E>(index, data)
    }
}

impl Free for Ptr<E> {
    func free() {
        if (this.heap) free(this.pointer)
    }
}

/// Allocates on the heap, where the amount
/// of bytes allocated is the size of the type parameter times `size`.
/// The returned pointer is memory-managed, and the backing
/// memory will be freed once the pointer gets picked up
/// by the GC.
public func allocate<T>(size: i64) -> Ptr<T> {
    var ptr = if (size == 0) 0 else malloc(size_of::<T>() * size)
    Ptr::<T>(ptr, size != 0)
}

/// Copies elements in memory at `src` to `dst`,
/// copying from index 0 until `len`.
/// Does not do any memory safety checks.
public func copy_ptr<T>(src: Ptr<T>, dst: Ptr<T>, len: i64) {
    for (i from 0 to len) {
        dst.set(i, src.element_at_index(i))
    }
}

/// Will increment the reference count on a value by 1.
/// Will cause memory leaks if not careful!
public func inc_ref<T>(value: T) {
    gelixrs_inc_ref::<T>(value)
}

/// Will decrement the reference count on a value by 1.
/// Will cause use-after-free bugs if not careful!
public func dec_ref<T>(value: T) {
    gelixrs_dec_ref::<T>(value)
}
